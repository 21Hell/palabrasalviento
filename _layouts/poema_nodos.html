---
layout: default
---
<style>
.poema-nodos-container {
  max-width: 1100px;
  margin: 40px auto;
  position: relative;
  min-height: 80vh;
  padding: 2em;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 8px 30px rgba(0,0,0,0.08);
}

.nodo {
  position: absolute;
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 0.9rem 1rem;
  border-radius: 8px;
  max-width: 320px;
  width: fit-content;
  min-width: 0;
  box-sizing: border-box;
  line-height: 1.45;
  font-family: 'Georgia', serif;
  font-size: 1.05rem;
  box-shadow: 0 6px 18px rgba(0,0,0,0.25);
  cursor: grab;
  user-select: none;
}

.nodo.pos-1 { top: 3%; left: 4%; }
.nodo.pos-2 { top: 8%; right: 6%; }
.nodo.pos-3 { top: 18%; left: 30%; }
.nodo.pos-4 { top: 30%; left: 6%; }
.nodo.pos-5 { top: 40%; right: 8%; }
.nodo.pos-6 { top: 52%; left: 18%; }
.nodo.pos-7 { top: 60%; right: 22%; }
.nodo.pos-8 { top: 72%; left: 6%; }
.nodo.pos-9 { top: 78%; right: 6%; }
.nodo.pos-10{ top: 20%; left: 60%; }

/* responsive: stack on small screens */
@media (max-width: 700px) {
  .nodo { position: static; width: auto; margin: 0.6rem 0; }
  .poema-nodos-container { padding: 1rem; }
  /* hide connections and disable dragging on small screens */
  .nodo { cursor: default; }
  svg.poema-connections { display: none; }
}
</style>

<div class="poema-nodos-container">
  <h1 style="font-family:'Times New Roman', serif;">{{ page.title }}</h1>
  <p style="color:#666;">{{ page.date | date: "%Y" }}</p>

  <!-- SVG overlay for connection lines -->
  <svg class="poema-connections" xmlns="http://www.w3.org/2000/svg" style="position:absolute; inset:0; width:100%; height:100%; pointer-events:none; overflow:visible; z-index:1;">
  </svg>

  {% assign i = 0 %}
  {% for p in page.parrafos %}
    {% assign i = i | plus: 1 %}
    <div class="nodo pos-{{ i }}" data-idx="{{ i }}" style="z-index:2;">
      {{ p.texto }}
    </div>
  {% endfor %}

  <div class="poema-author" style="position:absolute; right:18px; bottom:56px; color:#888; z-index:3;">Autor: <a href="https://www.instagram.com/cwolf_imc/" target="_blank" rel="noopener" style="color:#0056b3; text-decoration:none;">Carlos Wolf</a></div>

  <!-- in-card navigation positioned beneath the author -->
  <div style="position:absolute; right:18px; bottom:10px; z-index:3;">
    {% include next-button.html %}
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function(){
  const container = document.querySelector('.poema-nodos-container');
  const svg = container.querySelector('svg.poema-connections');
  const nodes = Array.from(container.querySelectorAll('.nodo'));

  function getCenter(el){
    const rect = el.getBoundingClientRect();
    const crect = container.getBoundingClientRect();
    return { x: rect.left - crect.left + rect.width/2, y: rect.top - crect.top + rect.height/2 };
  }

  function drawLines(edges){
    while(svg.firstChild) svg.removeChild(svg.firstChild);
    edges.forEach(pair => {
      const a = getCenter(nodes[pair[0]]);
      const b = getCenter(nodes[pair[1]]);
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', a.x);
      line.setAttribute('y1', a.y);
      line.setAttribute('x2', b.x);
      line.setAttribute('y2', b.y);
      line.setAttribute('stroke', 'rgba(0,0,0,0.18)');
      line.setAttribute('stroke-width', '2');
      line.setAttribute('stroke-linecap', 'round');
      svg.appendChild(line);
    });
  }

  function randomizePositions(){
    const crect = container.getBoundingClientRect();
    const placed = [];
    nodes.forEach(n => {
      const width = Math.max(n.offsetWidth, 160);
      const height = n.offsetHeight;
      const maxW = Math.max(20, crect.width - width - 20);
      const maxH = Math.max(20, crect.height - height - 20);
      let left, top, tries = 0;
      do {
        left = Math.random() * maxW + 20;
        top = Math.random() * maxH + 20;
        const rect = { left, top, right: left + width, bottom: top + height };
        const overlapping = placed.some(p => !(rect.right < p.left || rect.left > p.right || rect.bottom < p.top || rect.top > p.bottom));
        if(!overlapping) break;
        tries++;
      } while(tries < 30);
      // fallback: allow overlap after many tries
      n.style.left = left + 'px';
      n.style.top = top + 'px';
      n.style.position = 'absolute';
      placed.push({ left: left, top: top, right: left + width, bottom: top + height });
    });
  }

  function randomEdges(){
    const edges = [];
    const N = nodes.length;
    for(let i=0;i<N;i++){
      let j = i;
      while(j===i) j = Math.floor(Math.random()*N);
      edges.push([i,j]);
    }
    // add a few extra random edges
    const extra = Math.max(1, Math.floor(N/2));
    for(let k=0;k<extra;k++){
      let a = Math.floor(Math.random()*N);
      let b = a;
      while(b===a) b = Math.floor(Math.random()*N);
      edges.push([a,b]);
    }
    return edges;
  }

  // Make nodes draggable
  nodes.forEach(node => {
    node.addEventListener('pointerdown', startDrag);
    node.style.touchAction = 'none';
  });

  let dragEl = null, startX=0, startY=0, origX=0, origY=0;
  function startDrag(e){
    if(window.matchMedia('(max-width:700px)').matches) return;
    dragEl = e.currentTarget;
    nodes.forEach(nd => nd.style.zIndex = 2);
    dragEl.style.zIndex = 9999;
    dragEl.setPointerCapture(e.pointerId);
    const rect = dragEl.getBoundingClientRect();
    const crect = container.getBoundingClientRect();
    startX = e.clientX; startY = e.clientY;
    origX = rect.left - crect.left;
    origY = rect.top - crect.top;
    dragEl.style.cursor = 'grabbing';
    dragEl.style.transition = 'none';
    dragEl.addEventListener('pointermove', onDrag);
    dragEl.addEventListener('pointerup', endDrag);
    dragEl.addEventListener('pointercancel', endDrag);
  }

  function onDrag(e){
    if(!dragEl) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    let nx = origX + dx;
    let ny = origY + dy;
    const crect = container.getBoundingClientRect();
    const nrect = dragEl.getBoundingClientRect();
    nx = Math.max(0, Math.min(nx, crect.width - nrect.width));
    ny = Math.max(0, Math.min(ny, crect.height - nrect.height));
    dragEl.style.left = nx + 'px';
    dragEl.style.top = ny + 'px';
    drawLines(currentEdges);
  }

  function endDrag(e){
    if(!dragEl) return;
    try{ dragEl.releasePointerCapture(e.pointerId); }catch(_){}
    dragEl.style.cursor = 'grab';
    dragEl.style.transition = '';
    dragEl.removeEventListener('pointermove', onDrag);
    dragEl.removeEventListener('pointerup', endDrag);
    dragEl.removeEventListener('pointercancel', endDrag);
    dragEl.style.zIndex = 2;
    dragEl = null;
  }

  let currentEdges = randomEdges();
  setTimeout(function(){
    randomizePositions();
    drawLines(currentEdges);
  }, 120);

  window.addEventListener('resize', function(){
    randomizePositions();
    drawLines(currentEdges);
  });

  document.addEventListener('keydown', function(e){
    if(e.key === 'r' || e.key === 'R'){
      currentEdges = randomEdges();
      randomizePositions();
      drawLines(currentEdges);
    }
  });
});
</script>
